<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Algorithm Complexity Visualizer</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --cream: #F5F0E8;
      --cream-dark: #E8E0D4;
      --text: #292521;
      --text-secondary: #6B6560;
      --text-muted: #9A9590;
      --border: #D4CEC4;
      --white: #FFFFFF;
      --teal: #2A9D8F;
      --teal-light: #E8F5F3;
      --teal-bg: #3BA99B;
      --orange: #D97757;
      --green: #16A34A;
      --blue: #3B82F6;
      --yellow: #CA8A04;
      --red: #DC2626;
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'IBM Plex Sans', system-ui, sans-serif;
      background: var(--cream);
      color: var(--text);
      line-height: 1.6;
      min-height: 100vh;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 40px 24px;
    }
    
    /* Header */
    h1 {
      font-size: 1.75rem;
      font-weight: 600;
      letter-spacing: -0.02em;
      margin-bottom: 8px;
    }
    
    .subtitle {
      color: var(--text-secondary);
      margin-bottom: 32px;
    }
    
    /* Algorithm Selector */
    .algo-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 24px;
      flex-wrap: wrap;
    }
    
    .algo-tab {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 18px;
      background: var(--white);
      border: 1px solid var(--border);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .algo-tab:hover {
      border-color: var(--teal);
    }
    
    .algo-tab.active {
      border-color: var(--teal);
      background: var(--teal-light);
    }
    
    .algo-tab-name {
      font-weight: 500;
    }
    
    .algo-tab-complexity {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.75rem;
      font-weight: 500;
      padding: 3px 8px;
      border-radius: 4px;
    }
    
    .algo-tab-complexity.green { background: rgba(22, 163, 74, 0.1); color: var(--green); }
    .algo-tab-complexity.blue { background: rgba(59, 130, 246, 0.1); color: var(--blue); }
    .algo-tab-complexity.yellow { background: rgba(202, 138, 4, 0.1); color: var(--yellow); }
    .algo-tab-complexity.orange { background: rgba(217, 119, 87, 0.1); color: var(--orange); }
    .algo-tab-complexity.red { background: rgba(220, 38, 38, 0.1); color: var(--red); }
    
    /* Input Section */
    .input-section {
      display: flex;
      gap: 16px;
      margin-bottom: 24px;
      flex-wrap: wrap;
    }
    
    .input-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .input-group label {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }
    
    .input-field {
      display: flex;
      align-items: center;
      background: var(--white);
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }
    
    .input-icon {
      padding: 10px 12px;
      background: var(--cream);
      border-right: 1px solid var(--border);
      color: var(--text-muted);
    }
    
    .input-field input {
      border: none;
      padding: 10px 14px;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.9rem;
      width: 200px;
      background: transparent;
    }
    
    .input-field input:focus {
      outline: none;
    }
    
    .input-hint {
      font-size: 0.75rem;
      color: var(--text-muted);
    }
    
    /* Visualizer Container */
    .visualizer {
      background: var(--white);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
    }
    
    .visualizer-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      border-bottom: 1px solid var(--border);
      background: var(--cream);
    }
    
    .visualizer-title {
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
    }
    
    .visualizer-controls-top {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    
    .lang-select {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.85rem;
      color: var(--text);
      cursor: pointer;
    }
    
    .fullscreen-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.85rem;
      color: var(--text-secondary);
      background: none;
      border: none;
      cursor: pointer;
    }
    
    .fullscreen-btn:hover {
      color: var(--text);
    }
    
    /* Main Content */
    .visualizer-content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      min-height: 350px;
    }
    
    @media (max-width: 800px) {
      .visualizer-content {
        grid-template-columns: 1fr;
      }
    }
    
    /* Code Panel */
    .code-panel {
      padding: 20px;
      border-right: 1px solid var(--border);
      overflow: auto;
      background: var(--white);
    }
    
    .code-line {
      display: flex;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.85rem;
      line-height: 1.8;
      padding: 2px 8px;
      margin: 0 -8px;
      border-radius: 4px;
      transition: background 0.2s ease;
    }
    
    .code-line.highlight {
      background: var(--teal-light);
    }
    
    .code-line.executed {
      background: rgba(42, 157, 143, 0.05);
    }
    
    .line-number {
      color: var(--text-muted);
      width: 24px;
      text-align: right;
      margin-right: 16px;
      user-select: none;
    }
    
    .code-text {
      flex: 1;
    }
    
    .code-text .keyword { color: #2A9D8F; }
    .code-text .function { color: var(--text); }
    .code-text .string { color: #B5838D; }
    .code-text .number { color: var(--orange); }
    .code-text .comment { color: var(--text-muted); }
    .code-text .builtin { color: #6D597A; }
    .code-text .boolean { color: var(--orange); }
    
    /* Visualization Panel */
    .viz-panel {
      padding: 24px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--cream);
      position: relative;
    }
    
    /* Array Visualization */
    .array-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    
    .pointers-row {
      display: flex;
      gap: 0;
      height: 40px;
      align-items: flex-end;
    }
    
    .pointer-slot {
      width: 48px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }
    
    .pointer-label {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.8rem;
      font-weight: 500;
      color: var(--teal);
    }
    
    .pointer-arrow {
      color: var(--teal);
      font-size: 1.2rem;
    }
    
    .array-row {
      display: flex;
      gap: 0;
    }
    
    .array-cell {
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--teal-bg);
      color: white;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 1rem;
      font-weight: 600;
      border: 2px solid var(--teal);
      transition: all 0.3s ease;
    }
    
    .array-cell:first-child {
      border-radius: 6px 0 0 6px;
    }
    
    .array-cell:last-child {
      border-radius: 0 6px 6px 0;
    }
    
    .array-cell.active {
      transform: scale(1.1) translateY(-4px);
      z-index: 10;
      box-shadow: 0 4px 12px rgba(42, 157, 143, 0.3);
    }
    
    .array-cell.found {
      background: var(--green);
      border-color: var(--green);
    }
    
    .array-cell.comparing {
      background: var(--orange);
      border-color: var(--orange);
    }
    
    .array-cell.inactive {
      opacity: 0.4;
    }
    
    /* Bracket/Sum Display */
    .bracket-row {
      display: flex;
      align-items: flex-start;
      gap: 0;
      height: 30px;
      margin-top: 4px;
    }
    
    .bracket-slot {
      width: 48px;
      position: relative;
    }
    
    .bracket-line {
      position: absolute;
      height: 12px;
      border: 2px solid var(--teal);
      border-top: none;
    }
    
    .bracket-line.left {
      left: 50%;
      right: -2px;
      border-right: none;
      border-radius: 0 0 0 6px;
    }
    
    .bracket-line.right {
      left: -2px;
      right: 50%;
      border-left: none;
      border-radius: 0 0 6px 0;
    }
    
    .bracket-line.middle {
      left: -2px;
      right: -2px;
      border-left: none;
      border-right: none;
    }
    
    .sum-value {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.85rem;
      color: var(--text);
      white-space: nowrap;
    }
    
    /* State Display */
    .state-display {
      margin-top: 20px;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.9rem;
      color: var(--text);
    }
    
    .state-message {
      margin-top: 16px;
      font-family: 'IBM Plex Sans', sans-serif;
      font-size: 1rem;
      font-weight: 500;
      color: var(--teal);
    }
    
    .state-message.success {
      color: var(--green);
    }
    
    /* Playback Controls */
    .playback-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px;
      border-top: 1px solid var(--border);
      background: var(--white);
    }
    
    .control-btn {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s ease;
    }
    
    .control-btn:hover {
      background: var(--cream);
      color: var(--text);
    }
    
    .control-btn.play-btn {
      width: 40px;
      height: 40px;
      background: var(--teal);
      color: white;
    }
    
    .control-btn.play-btn:hover {
      background: #238B7E;
    }
    
    .control-btn.play-btn.playing {
      background: var(--orange);
    }
    
    .control-btn svg {
      width: 18px;
      height: 18px;
    }
    
    .progress-container {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .progress-bar {
      flex: 1;
      height: 6px;
      background: var(--cream-dark);
      border-radius: 3px;
      overflow: hidden;
      cursor: pointer;
    }
    
    .progress-fill {
      height: 100%;
      background: var(--teal);
      border-radius: 3px;
      transition: width 0.1s ease;
    }
    
    .progress-slider {
      -webkit-appearance: none;
      flex: 1;
      height: 6px;
      border-radius: 3px;
      background: var(--cream-dark);
      outline: none;
    }
    
    .progress-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--teal);
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(42, 157, 143, 0.3);
    }
    
    .step-counter {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.85rem;
      color: var(--text-secondary);
      min-width: 60px;
      text-align: center;
    }
    
    .speed-btn {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.85rem;
      padding: 6px 10px;
      background: var(--cream);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      cursor: pointer;
    }
    
    .speed-btn:hover {
      background: var(--cream-dark);
    }
    
    .more-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 1.2rem;
    }
    
    /* Explanation */
    .explanation {
      margin-top: 24px;
      padding: 20px;
      background: var(--white);
      border: 1px solid var(--border);
      border-radius: 12px;
    }
    
    .explanation p {
      color: var(--text-secondary);
      margin-bottom: 12px;
    }
    
    .explanation strong {
      color: var(--text);
    }
    
    .inline-code {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.85em;
      background: var(--teal-light);
      color: var(--teal);
      padding: 2px 6px;
      border-radius: 4px;
    }
    
    /* Complexity Badge inline */
    .complexity-badge {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.8rem;
      font-weight: 500;
      padding: 2px 8px;
      border-radius: 4px;
      background: rgba(42, 157, 143, 0.1);
      color: var(--teal);
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Algorithm Complexity Visualizer</h1>
    <p class="subtitle">Step through algorithms to understand their time complexity</p>
    
    <!-- Algorithm Tabs -->
    <div class="algo-tabs" id="algoTabs"></div>
    
    <!-- Input Section -->
    <div class="input-section" id="inputSection"></div>
    
    <!-- Visualizer -->
    <div class="visualizer">
      <div class="visualizer-header">
        <span class="visualizer-title">VISUALIZATION</span>
        <div class="visualizer-controls-top">
          <div class="lang-select">
            Python <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>
          </div>
          <button class="fullscreen-btn">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
            </svg>
            Full Screen
          </button>
        </div>
      </div>
      
      <div class="visualizer-content">
        <div class="code-panel" id="codePanel"></div>
        <div class="viz-panel" id="vizPanel"></div>
      </div>
      
      <div class="playback-controls">
        <button class="control-btn" id="resetBtn" title="Reset">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
            <path d="M3 3v5h5"/>
          </svg>
        </button>
        <button class="control-btn" id="prevBtn" title="Previous">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M15 18l-6-6 6-6"/>
          </svg>
        </button>
        <button class="control-btn" id="nextBtn" title="Next">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M9 18l6-6-6-6"/>
          </svg>
        </button>
        <button class="control-btn play-btn" id="playBtn" title="Play">
          <svg id="playIcon" viewBox="0 0 24 24" fill="currentColor">
            <polygon points="5 3 19 12 5 21 5 3"/>
          </svg>
        </button>
        <div class="progress-container">
          <input type="range" class="progress-slider" id="progressSlider" min="0" max="100" value="0">
          <span class="step-counter" id="stepCounter">0 / 0</span>
        </div>
        <button class="speed-btn" id="speedBtn">1x</button>
        <button class="more-btn" title="More options">⋮</button>
      </div>
    </div>
    
    <!-- Explanation -->
    <div class="explanation" id="explanation"></div>
  </div>

  <script>
    // Algorithm definitions
    const algorithms = {
      twoPointers: {
        name: 'Two Pointers',
        complexity: 'O(n)',
        complexityClass: 'yellow',
        description: 'Find if any two numbers sum to target',
        inputs: [
          { name: 'nums', type: 'array', default: [1, 3, 4, 6, 8, 10, 13], hint: 'sorted array' },
          { name: 'target', type: 'number', default: 13, hint: 'target sum' }
        ],
        code: `def isPairSum(nums, target):
    left, right = 0, len(nums) - 1
    while left < right:
        current_sum = nums[left] + nums[right]
        if current_sum == target:
            return True
        elif current_sum < target:
            left += 1
        else:
            right -= 1
    return False`,
        generateSteps: (nums, target) => {
          const steps = [];
          let left = 0, right = nums.length - 1;
          
          steps.push({
            line: 1,
            left, right,
            message: 'Initialize left and right pointers',
            state: `left = ${left}, right = ${right}`
          });
          
          while (left < right) {
            const sum = nums[left] + nums[right];
            
            steps.push({
              line: 3,
              left, right, sum,
              showSum: true,
              message: `Calculate sum: ${nums[left]} + ${nums[right]} = ${sum}`,
              state: `left = ${left}, right = ${right}`
            });
            
            if (sum === target) {
              steps.push({
                line: 4,
                left, right, sum,
                found: true,
                showSum: true,
                message: 'pair found!',
                success: true,
                state: `left = ${left}, right = ${right}`
              });
              return steps;
            } else if (sum < target) {
              steps.push({
                line: 6,
                left, right, sum,
                showSum: true,
                message: `Sum ${sum} < target ${target}, move left pointer`,
                state: `left = ${left}, right = ${right}`
              });
              left++;
            } else {
              steps.push({
                line: 8,
                left, right, sum,
                showSum: true,
                message: `Sum ${sum} > target ${target}, move right pointer`,
                state: `left = ${left}, right = ${right}`
              });
              right--;
            }
          }
          
          steps.push({
            line: 9,
            left, right,
            message: 'No pair found',
            state: `left = ${left}, right = ${right}`
          });
          
          return steps;
        }
      },
      
      binarySearch: {
        name: 'Binary Search',
        complexity: 'O(log n)',
        complexityClass: 'blue',
        description: 'Find target in sorted array',
        inputs: [
          { name: 'nums', type: 'array', default: [1, 3, 4, 6, 8, 10, 13, 15, 18, 21], hint: 'sorted array' },
          { name: 'target', type: 'number', default: 10, hint: 'target value' }
        ],
        code: `def binarySearch(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1`,
        generateSteps: (nums, target) => {
          const steps = [];
          let left = 0, right = nums.length - 1;
          
          steps.push({
            line: 1,
            left, right,
            message: 'Initialize search range',
            state: `left = ${left}, right = ${right}`
          });
          
          while (left <= right) {
            const mid = Math.floor((left + right) / 2);
            
            steps.push({
              line: 3,
              left, right, mid,
              message: `Calculate mid: (${left} + ${right}) / 2 = ${mid}`,
              state: `left = ${left}, right = ${right}, mid = ${mid}`
            });
            
            if (nums[mid] === target) {
              steps.push({
                line: 4,
                left, right, mid,
                found: true,
                message: `Found target ${target} at index ${mid}!`,
                success: true,
                state: `mid = ${mid}`
              });
              return steps;
            } else if (nums[mid] < target) {
              steps.push({
                line: 6,
                left, right, mid,
                message: `${nums[mid]} < ${target}, search right half`,
                state: `left = ${left}, right = ${right}, mid = ${mid}`
              });
              left = mid + 1;
            } else {
              steps.push({
                line: 8,
                left, right, mid,
                message: `${nums[mid]} > ${target}, search left half`,
                state: `left = ${left}, right = ${right}, mid = ${mid}`
              });
              right = mid - 1;
            }
          }
          
          steps.push({
            line: 9,
            left, right,
            message: 'Target not found',
            state: `left = ${left}, right = ${right}`
          });
          
          return steps;
        }
      },
      
      linearSearch: {
        name: 'Linear Search',
        complexity: 'O(n)',
        complexityClass: 'yellow',
        description: 'Find target by checking each element',
        inputs: [
          { name: 'nums', type: 'array', default: [5, 2, 8, 1, 9, 3, 7], hint: 'array' },
          { name: 'target', type: 'number', default: 9, hint: 'target value' }
        ],
        code: `def linearSearch(nums, target):
    for i in range(len(nums)):
        if nums[i] == target:
            return i
    return -1`,
        generateSteps: (nums, target) => {
          const steps = [];
          
          for (let i = 0; i < nums.length; i++) {
            steps.push({
              line: 1,
              i,
              message: `Check index ${i}: nums[${i}] = ${nums[i]}`,
              state: `i = ${i}`
            });
            
            if (nums[i] === target) {
              steps.push({
                line: 2,
                i,
                found: true,
                message: `Found target ${target} at index ${i}!`,
                success: true,
                state: `i = ${i}`
              });
              return steps;
            }
          }
          
          steps.push({
            line: 4,
            message: 'Target not found',
            state: ''
          });
          
          return steps;
        }
      },
      
      bubbleSort: {
        name: 'Bubble Sort',
        complexity: 'O(n²)',
        complexityClass: 'orange',
        description: 'Sort by swapping adjacent elements',
        inputs: [
          { name: 'nums', type: 'array', default: [5, 2, 8, 1, 9], hint: 'unsorted array' }
        ],
        code: `def bubbleSort(nums):
    n = len(nums)
    for i in range(n):
        for j in range(n - i - 1):
            if nums[j] > nums[j + 1]:
                nums[j], nums[j+1] = nums[j+1], nums[j]
    return nums`,
        generateSteps: (nums) => {
          const steps = [];
          const arr = [...nums];
          const n = arr.length;
          
          steps.push({
            line: 1,
            array: [...arr],
            message: 'Start bubble sort',
            state: `n = ${n}`
          });
          
          for (let i = 0; i < n; i++) {
            for (let j = 0; j < n - i - 1; j++) {
              steps.push({
                line: 3,
                array: [...arr],
                comparing: [j, j + 1],
                message: `Compare ${arr[j]} and ${arr[j + 1]}`,
                state: `i = ${i}, j = ${j}`
              });
              
              if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                steps.push({
                  line: 5,
                  array: [...arr],
                  swapped: [j, j + 1],
                  message: `Swap! ${arr[j + 1]} > ${arr[j]}`,
                  state: `i = ${i}, j = ${j}`
                });
              }
            }
          }
          
          steps.push({
            line: 6,
            array: [...arr],
            sorted: true,
            message: 'Array sorted!',
            success: true,
            state: ''
          });
          
          return steps;
        }
      }
    };
    
    // State
    let currentAlgo = 'twoPointers';
    let steps = [];
    let currentStep = 0;
    let isPlaying = false;
    let playInterval = null;
    let speed = 1;
    let inputs = {};
    
    // DOM Elements
    const algoTabs = document.getElementById('algoTabs');
    const inputSection = document.getElementById('inputSection');
    const codePanel = document.getElementById('codePanel');
    const vizPanel = document.getElementById('vizPanel');
    const stepCounter = document.getElementById('stepCounter');
    const progressSlider = document.getElementById('progressSlider');
    const playBtn = document.getElementById('playBtn');
    const playIcon = document.getElementById('playIcon');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const resetBtn = document.getElementById('resetBtn');
    const speedBtn = document.getElementById('speedBtn');
    const explanation = document.getElementById('explanation');
    
    // Initialize
    function init() {
      renderAlgoTabs();
      loadAlgorithm(currentAlgo);
    }
    
    function renderAlgoTabs() {
      algoTabs.innerHTML = Object.entries(algorithms).map(([key, algo]) => `
        <div class="algo-tab ${key === currentAlgo ? 'active' : ''}" data-algo="${key}">
          <span class="algo-tab-name">${algo.name}</span>
          <span class="algo-tab-complexity ${algo.complexityClass}">${algo.complexity}</span>
        </div>
      `).join('');
      
      algoTabs.querySelectorAll('.algo-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          currentAlgo = tab.dataset.algo;
          document.querySelectorAll('.algo-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          loadAlgorithm(currentAlgo);
        });
      });
    }
    
    function loadAlgorithm(algoKey) {
      const algo = algorithms[algoKey];
      
      // Reset state
      stopPlaying();
      currentStep = 0;
      
      // Set default inputs
      inputs = {};
      algo.inputs.forEach(input => {
        inputs[input.name] = input.default;
      });
      
      // Render inputs
      renderInputs(algo);
      
      // Render code
      renderCode(algo.code);
      
      // Generate steps
      generateSteps();
      
      // Render explanation
      renderExplanation(algo);
    }
    
    function renderInputs(algo) {
      inputSection.innerHTML = algo.inputs.map(input => `
        <div class="input-group">
          <label>${input.name}</label>
          <div class="input-field">
            <span class="input-icon">⌨</span>
            <input type="text" id="input-${input.name}" value="${input.type === 'array' ? JSON.stringify(input.default) : input.default}">
          </div>
          <span class="input-hint">${input.hint}</span>
        </div>
      `).join('');
      
      // Add input listeners
      algo.inputs.forEach(input => {
        const el = document.getElementById(`input-${input.name}`);
        el.addEventListener('change', () => {
          try {
            inputs[input.name] = input.type === 'array' ? JSON.parse(el.value) : parseInt(el.value);
            generateSteps();
          } catch (e) {
            console.error('Invalid input');
          }
        });
      });
    }
    
    function renderCode(code) {
      const lines = code.split('\n');
      codePanel.innerHTML = lines.map((line, i) => `
        <div class="code-line" data-line="${i}">
          <span class="line-number">${i + 1}</span>
          <span class="code-text">${highlightSyntax(line)}</span>
        </div>
      `).join('');
    }
    
    function highlightSyntax(code) {
      return code
        .replace(/\b(def|for|while|if|elif|else|return|in|and|or|not)\b/g, '<span class="keyword">$1</span>')
        .replace(/\b(len|range|print)\b/g, '<span class="builtin">$1</span>')
        .replace(/\b(True|False|None)\b/g, '<span class="boolean">$1</span>')
        .replace(/\b(\d+)\b/g, '<span class="number">$1</span>')
        .replace(/(#.*)/g, '<span class="comment">$1</span>');
    }
    
    function generateSteps() {
      const algo = algorithms[currentAlgo];
      const args = algo.inputs.map(input => inputs[input.name]);
      steps = algo.generateSteps(...args);
      currentStep = 0;
      updateUI();
    }
    
    function renderVisualization() {
      const algo = algorithms[currentAlgo];
      const step = steps[currentStep] || {};
      
      if (currentAlgo === 'bubbleSort') {
        renderBubbleSortViz(step);
      } else if (currentAlgo === 'linearSearch') {
        renderLinearSearchViz(step);
      } else if (currentAlgo === 'binarySearch') {
        renderBinarySearchViz(step);
      } else {
        renderTwoPointersViz(step);
      }
    }
    
    function renderTwoPointersViz(step) {
      const nums = inputs.nums;
      
      let html = '<div class="array-container">';
      
      // Pointers
      html += '<div class="pointers-row">';
      for (let i = 0; i < nums.length; i++) {
        html += '<div class="pointer-slot">';
        if (step.left === i) {
          html += '<span class="pointer-label">left</span><span class="pointer-arrow">↓</span>';
        } else if (step.right === i) {
          html += '<span class="pointer-label">right</span><span class="pointer-arrow">↓</span>';
        }
        html += '</div>';
      }
      html += '</div>';
      
      // Array
      html += '<div class="array-row">';
      for (let i = 0; i < nums.length; i++) {
        let classes = 'array-cell';
        if (step.left === i || step.right === i) classes += ' active';
        if (step.found && (step.left === i || step.right === i)) classes += ' found';
        html += `<div class="${classes}">${nums[i]}</div>`;
      }
      html += '</div>';
      
      // Bracket showing sum
      if (step.showSum && step.left !== undefined && step.right !== undefined) {
        html += '<div class="bracket-row">';
        for (let i = 0; i < nums.length; i++) {
          html += '<div class="bracket-slot">';
          if (i === step.left) {
            html += '<div class="bracket-line left"></div>';
          } else if (i === step.right) {
            html += '<div class="bracket-line right"></div>';
            html += `<div class="sum-value">${step.sum}</div>`;
          } else if (i > step.left && i < step.right) {
            html += '<div class="bracket-line middle"></div>';
          }
          html += '</div>';
        }
        html += '</div>';
      }
      
      html += '</div>';
      
      // State
      html += `<div class="state-display">${step.state || ''}</div>`;
      
      // Message
      if (step.message) {
        html += `<div class="state-message ${step.success ? 'success' : ''}">${step.message}</div>`;
      }
      
      vizPanel.innerHTML = html;
    }
    
    function renderBinarySearchViz(step) {
      const nums = inputs.nums;
      
      let html = '<div class="array-container">';
      
      // Pointers
      html += '<div class="pointers-row">';
      for (let i = 0; i < nums.length; i++) {
        html += '<div class="pointer-slot">';
        if (step.mid === i) {
          html += '<span class="pointer-label">mid</span><span class="pointer-arrow">↓</span>';
        } else if (step.left === i) {
          html += '<span class="pointer-label">left</span><span class="pointer-arrow">↓</span>';
        } else if (step.right === i) {
          html += '<span class="pointer-label">right</span><span class="pointer-arrow">↓</span>';
        }
        html += '</div>';
      }
      html += '</div>';
      
      // Array
      html += '<div class="array-row">';
      for (let i = 0; i < nums.length; i++) {
        let classes = 'array-cell';
        if (step.mid === i) classes += ' active';
        if (step.found && step.mid === i) classes += ' found';
        if (step.left !== undefined && step.right !== undefined) {
          if (i < step.left || i > step.right) classes += ' inactive';
        }
        html += `<div class="${classes}">${nums[i]}</div>`;
      }
      html += '</div>';
      
      html += '</div>';
      
      // State
      html += `<div class="state-display">${step.state || ''}</div>`;
      
      // Message
      if (step.message) {
        html += `<div class="state-message ${step.success ? 'success' : ''}">${step.message}</div>`;
      }
      
      vizPanel.innerHTML = html;
    }
    
    function renderLinearSearchViz(step) {
      const nums = inputs.nums;
      
      let html = '<div class="array-container">';
      
      // Pointers
      html += '<div class="pointers-row">';
      for (let i = 0; i < nums.length; i++) {
        html += '<div class="pointer-slot">';
        if (step.i === i) {
          html += '<span class="pointer-label">i</span><span class="pointer-arrow">↓</span>';
        }
        html += '</div>';
      }
      html += '</div>';
      
      // Array
      html += '<div class="array-row">';
      for (let i = 0; i < nums.length; i++) {
        let classes = 'array-cell';
        if (step.i === i) classes += ' active';
        if (step.found && step.i === i) classes += ' found';
        html += `<div class="${classes}">${nums[i]}</div>`;
      }
      html += '</div>';
      
      html += '</div>';
      
      // State
      html += `<div class="state-display">${step.state || ''}</div>`;
      
      // Message
      if (step.message) {
        html += `<div class="state-message ${step.success ? 'success' : ''}">${step.message}</div>`;
      }
      
      vizPanel.innerHTML = html;
    }
    
    function renderBubbleSortViz(step) {
      const nums = step.array || inputs.nums;
      
      let html = '<div class="array-container">';
      
      // Array
      html += '<div class="array-row">';
      for (let i = 0; i < nums.length; i++) {
        let classes = 'array-cell';
        if (step.comparing && step.comparing.includes(i)) classes += ' comparing';
        if (step.swapped && step.swapped.includes(i)) classes += ' active';
        if (step.sorted) classes += ' found';
        html += `<div class="${classes}">${nums[i]}</div>`;
      }
      html += '</div>';
      
      html += '</div>';
      
      // State
      html += `<div class="state-display">${step.state || ''}</div>`;
      
      // Message
      if (step.message) {
        html += `<div class="state-message ${step.success ? 'success' : ''}">${step.message}</div>`;
      }
      
      vizPanel.innerHTML = html;
    }
    
    function highlightCodeLine() {
      document.querySelectorAll('.code-line').forEach(el => {
        el.classList.remove('highlight', 'executed');
      });
      
      const step = steps[currentStep];
      if (step && step.line !== undefined) {
        const lineEl = document.querySelector(`.code-line[data-line="${step.line}"]`);
        if (lineEl) lineEl.classList.add('highlight');
        
        // Mark previous lines as executed
        for (let i = 0; i < currentStep; i++) {
          const prevLine = steps[i]?.line;
          if (prevLine !== undefined) {
            const el = document.querySelector(`.code-line[data-line="${prevLine}"]`);
            if (el) el.classList.add('executed');
          }
        }
      }
    }
    
    function updateUI() {
      stepCounter.textContent = `${currentStep} / ${steps.length - 1}`;
      progressSlider.max = steps.length - 1;
      progressSlider.value = currentStep;
      
      highlightCodeLine();
      renderVisualization();
    }
    
    function nextStep() {
      if (currentStep < steps.length - 1) {
        currentStep++;
        updateUI();
      } else {
        stopPlaying();
      }
    }
    
    function prevStep() {
      if (currentStep > 0) {
        currentStep--;
        updateUI();
      }
    }
    
    function startPlaying() {
      isPlaying = true;
      playBtn.classList.add('playing');
      playIcon.innerHTML = '<rect x="6" y="4" width="4" height="16" fill="currentColor"/><rect x="14" y="4" width="4" height="16" fill="currentColor"/>';
      
      playInterval = setInterval(() => {
        if (currentStep < steps.length - 1) {
          currentStep++;
          updateUI();
        } else {
          stopPlaying();
        }
      }, 1000 / speed);
    }
    
    function stopPlaying() {
      isPlaying = false;
      playBtn.classList.remove('playing');
      playIcon.innerHTML = '<polygon points="5 3 19 12 5 21 5 3" fill="currentColor"/>';
      if (playInterval) {
        clearInterval(playInterval);
        playInterval = null;
      }
    }
    
    function renderExplanation(algo) {
      explanation.innerHTML = `
        <p><strong>${algo.name}</strong> has a time complexity of <span class="complexity-badge">${algo.complexity}</span>.</p>
        <p>${algo.description}. Use the controls to step through the algorithm and see how it works.</p>
      `;
    }
    
    // Event listeners
    playBtn.addEventListener('click', () => {
      if (isPlaying) {
        stopPlaying();
      } else {
        if (currentStep >= steps.length - 1) {
          currentStep = 0;
          updateUI();
        }
        startPlaying();
      }
    });
    
    prevBtn.addEventListener('click', prevStep);
    nextBtn.addEventListener('click', nextStep);
    
    resetBtn.addEventListener('click', () => {
      stopPlaying();
      currentStep = 0;
      updateUI();
    });
    
    progressSlider.addEventListener('input', () => {
      currentStep = parseInt(progressSlider.value);
      updateUI();
    });
    
    speedBtn.addEventListener('click', () => {
      const speeds = [0.5, 1, 1.5, 2];
      const currentIndex = speeds.indexOf(speed);
      speed = speeds[(currentIndex + 1) % speeds.length];
      speedBtn.textContent = speed + 'x';
      
      if (isPlaying) {
        stopPlaying();
        startPlaying();
      }
    });
    
    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowRight') nextStep();
      if (e.key === 'ArrowLeft') prevStep();
      if (e.key === ' ') {
        e.preventDefault();
        if (isPlaying) stopPlaying();
        else startPlaying();
      }
    });
    
    // Initialize
    init();
  </script>
</body>
</html>